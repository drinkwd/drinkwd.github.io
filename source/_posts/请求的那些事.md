---
title: 请求的那些事🙆‍♂️
tags: [Vue,Axios,Python,NodeJS]
categories: 技术
index_img: /img/blog_img/index17.png
banner_img: /img/blog_img/banner17.jpg
---
## 前言💕

- **前端**🤦‍♂️：你的接口又报`400`了。
- **后端**😡：我的接口没问题，`postman`请求都是好使的，肯定是你传参的问题。
- **前端**🤷‍♀️:你出来,咱俩掰扯掰扯🤜。
- **后端**🕵️‍♀️：来来来🤛。

拳脚相加的过程中问题解决了😅。上面的问题在工作当中肯定特别容易遇到，都是沟通上的问题今天就简单来说说，**前端请求入参**和**后台接收参数**🤞，让后端不在针对你🤣。

## 前期准备🎶
在工作当中用的最多的请求方式应该就是`get`或者`post`了😜,我们先下载[postman](https://www.postman.com/downloads/)或者[apifox](https://www.apifox.cn/?utm_source=google_ads&gclid=Cj0KCQjw4PKTBhD8ARIsAHChzRLi_i948TjbLH-nk4ynjm_uwUdMpv1o_5HBtA3tQ_6Sy6b60k9-OvwaAvOnEALw_wcB)你不是说你用`psotman`发请求吗，我就按照`postman`的形式来模拟前端请求😉。


![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/18823d1cb98840689913190023f30d37~tplv-k3u1fbpfcp-zoom-1.image)

## 操练起来🏓

### **GET请求**

一般`GET`请求的传参是把参数包含在`URL`中。
- 1.浏览器当前的实现是不允许`get`发送`body`,但后端应用可以发送。比如`nodejs`或`postman`。
- 2.特殊情况可以用后端服务转发一下, 因为前端不能使用`get`方法从浏览器里发送`body`。
- 3.`get`请求携带参数我们都采用`params`传参。

#### `postman`中发起一个带参数的`get`请求

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0b6f038450c44f4b821563dee645166e~tplv-k3u1fbpfcp-zoom-1.image)
你可以看到我在`url`中拼接了参数但是下方的`params`中自动增加了`key`和`value`不管你信不信🤔,但是确实他是自动增加的👀，如果在`params`中拼写参数，`url`也会自动增加对应的`key`和`value`👏。

#### 在`axios`中模拟`postman`发送`GET`请求
```javascript
// 第一种方式
axios
.get('/api/wpfk/getEnterpriseInfo',
{
  params:{
      qymc:"北京星巴克咖啡有限公司大庆万达店"
  }
})
.then(function(res){
   console.log(res)
})
// 第二种方式,多个参数通过&连接 例:a=1&b=2
axios
.get('/api/wpfk/getEnterpriseInfo?qymc=北京星巴克咖啡有限公司大庆万达店',
{
  params:{
     
  }
})
.then(function(res){
   console.log(res)
})
```
因为涉及到跨域问题,我需要在`vue.config.js`中做一个代理。

- `vue.config.js`
```javascript
const { defineConfig } = require('@vue/cli-service')
module.exports = defineConfig({
  transpileDependencies: true,
  devServer: {
    // 当访问/api/xxx时会被代理到127.0.0.1:3000/xxx
    proxy: {
      '/api': {
        target: 'http://127.0.0.1:3000/',
        pathRewrite: {'^/api' : ''}, 
        changeOrigin: true,
        secure: false,
      },
    }
  }
})

```
如果后端不知道怎么接这些参数你告诉他可以下岗啦🤷‍♀️，我把我熟悉的列在下面，如果你们也是用以下语言做后台，可以直接甩给他😘。

#### `nodeJs` `express`框架接收`GET`参数
```javascript
// 第一步: 导入express
const express = require('express');
// 第二步: 创建web服务器
const app = express();
app.get('/wpfk/getEnterpriseInfo',function(req,res,next){
    console.log(req.query)
    res.send('Hello world.')
})
// 第三步: 启动服务器
app.listen(3000, ()=>{
 console.log( ' 300服务启动了' )
 })
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1a5db03130f848a7b87c9bf4e78b556b~tplv-k3u1fbpfcp-zoom-1.image)

#### `python` `flask`框架接收`GET`参数
```python
from flask import Flask,request
app = Flask(__name__)

@app.route('/wpfk/getEnterpriseInfo',methods=["GET","POST"])
def index():
    # 接收get请求参数
    params1 = request.args.get("qymc")
    params2 = request.values.get("qymc")
    print(params1,params2)
    return '<h1>Hello World</h1>'

if __name__ == '__main__':
    app.run()
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f8c299479e91447f94632900815ed036~tplv-k3u1fbpfcp-zoom-1.image)


### **POST请求**

`POST`请求的消息主体放在`body`中🕵️‍♀️，服务端根据请求头中的`Content-Type`字段来获取消息主体的编码⽅式，进⽽进⾏解析数据，我主要来介绍比较常用的一下3种类型👇。

- `application/x-www-form-urlencoded` 👀

> 最常见的`POST`提交数据的⽅式如果不设置 `content-type` 属性🥩，默认为`application/x-www-form-urlencoded`⽅式提交数据🥙，提交的表单数据会转换为键值对并按照 `key1=val1&key2=val2` 的⽅式进⾏编码`key`和`val`都进⾏了`URL`转码🍞。

- `multipart/form-data` 👀
> 另⼀个常见的`POST`数据提交的⽅式😊,`Form`表单的`Content-Type`设置为`multipart/form-data`🛴，它会将表单的数据处理为⼀条消息，以标签为单元，⽤分隔符分开🎑。由于这种⽅式将数据有很多部分🚖，它既可以上传键值对，也可以上传⽂件，甚⾄多个⽂件🐱‍👓。

- `application/json` 👀
> `Content-Type: application/json`作为响应头⽐较常见🍱。实际上，现在越来越多的⼈把它作为请求头🥚，⽤来告诉服务端,消息主体是序列化后的`JSON`字符串🍞，其中⼀个好处就是`JSON`格式⽀持⽐键值对复杂得多的结构化数据🥡。

>**注意**：如果您有二进制（非字母数字）数据（或相当大的有效载荷）要传输🍙，请使用`multipart/form-data`，其他情况建议使用`application/x-www-form-urlencoded`或者`application/json`🍗。

#### `postman`中发起一个`post`请求(`application/x-www-form-urlencoded`)
![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b0437dde8cb54eabb4008c3f6711a9f6~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2f510ace3d9a4e48994367e98fc79e61~tplv-k3u1fbpfcp-zoom-1.image)
在`postman`中选择`body`下的`x-www-form-urlencoded`请求头会自动变成`Content-Type:application/x-www-form-urlencoded`,无需我们手动在去修改请求头🥞。



#### 在`axios`中模拟`postman`发送`POST`请求

- 第一种方式
```javascript
// 如果有多个参数用&连接 但是如果参数过多我们使用这种方式就显得太傻了，建议采用第二种方式
axios.post("/api/wpfk/getEnterpriseInfo","qymc=xxxxx").then(function (response) {
  console.log(response.data);
});
```
- 第二种方式 引用`qs`库
```javascript
// npm install qs --save 安装qs库
import qs from 'qs'
axios.post("/api/wpfk/getEnterpriseInfo",qs.stringify({
    qymc:'xxx'
})).then(function (response) {
    console.log(response.data);
});

```
#### `nodeJs` `express`框架接收`POST`参数
```javascript
// 第一步: 导入express
const express = require('express');
// 如果是post请求需要安装body-parser npm install body-parser --save
var bodyParser = require('body-parser')
// 第二步: 创建web服务器
const app = express();
// parse application/x-www-form-urlencoded
app.use(bodyParser.urlencoded({ extended: false }))


app.post('/wpfk/getEnterpriseInfo',function(req,res,next){
    console.log(req.body.qymc)
    res.send('Hello world.')
})
// 第三步: 启动服务器
app.listen(3000, ()=>{
 console.log( ' 300服务启动了' )
 })
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2d7788b5d0d24f33add34d0cad89c8f2~tplv-k3u1fbpfcp-zoom-1.image)

#### `python` `flask`框架接收`POST`参数
```python
from flask import Flask,request
app = Flask(__name__)

@app.route('/wpfk/getEnterpriseInfo',methods=["GET","POST"])
def index():
    # 接收POST请求参数 Content-Type为application/x-www-form-urlencoded
    params1 = request.values.get("qymc")
    print(params1)
    return '<h1>Hello World</h1>'

if __name__ == '__main__':
    app.run()
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/84d83d97810449cf9b07e5e92f23e35e~tplv-k3u1fbpfcp-zoom-1.image)

#### `postman`中发起一个`post`请求(`multipart/form-data`)
![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/739a18a386d1431aaafc02e86b51ce5f~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/35df32fc37464773962d4d319182c06b~tplv-k3u1fbpfcp-zoom-1.image)

`postman`中选择`body`下`form-data`请求头会自动变成`Content-Type:multipart/form-data`,无需我们手动在去修改请求头🍤。


#### 在`axios`中模拟`postman`发送`POST`请求
```javascript
// 需要手动设置请求头
axios.post("/api/wpfk/getEnterpriseInfo",{
    qymc:'formdata'
},{
  headers:{
    'Content-Type': 'multipart/form-data'
  }
}).then(function (response) {
    console.log(response.data);
});
```
#### `nodeJs` `express`框架接收`POST`参数
```javascript
// 第一步: 导入express
const express = require('express');
// 解析multipart/form-data需要使用express-formidable  
// 下载包 npm install express-formidable
const formidable = require('express-formidable') // 引入
// 第二步: 创建web服务器
const app = express();
app.use(formidable());

app.post('/wpfk/getEnterpriseInfo',function(req,res,next){
    // req.fields; // 非文件项
  	// req.files; // 文件项
    console.log(req.fields.qymc);
    res.send('Hello world.')
})
// 第三步: 启动服务器
app.listen(3000, ()=>{
 console.log( ' 300服务启动了' )
 })
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6b927f40d85643a0a63a211bc295e049~tplv-k3u1fbpfcp-zoom-1.image)

#### `python` `flask`框架接收`POST`参数
``` python
from flask import Flask,request
app = Flask(__name__)

@app.route('/wpfk/getEnterpriseInfo',methods=["GET","POST"])
def index():
    # 接收POST请求参数 Content-Type为multipart/form-data
    params1 = request.form.get("qymc")
    print(params1)
    return '<h1>Hello World</h1>'

if __name__ == '__main__':
    app.run()
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c5b7979330b540adadda3762f785a346~tplv-k3u1fbpfcp-zoom-1.image)

#### `postman`中发起一个`post`请求(`application/json`)
![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1917d5ba583d4b65a1f338dafe09bb56~tplv-k3u1fbpfcp-zoom-1.image)
![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0b6de9786a394cacb46fe481145b5cf6~tplv-k3u1fbpfcp-zoom-1.image)
在`postman`中选择`body`下的`row `右侧类型选择`JSON`请求头会自动变成`Content-Type:application/json`,无需我们手动在去修改请求头🍬。
> 注意：写内容的时候一定要是标准的`JSON`使用双引号。

#### 在`axios`中模拟`postman`发送`POST`请求
```javascript
axios.post("/api/wpfk/getEnterpriseInfo", {
    qymc: "applictionJSON",
  })
  .then(function (response) {
     console.log(response.data);
  });
```
#### `nodeJs` `express`框架接收`POST`参数
```javascript
// 第一步: 导入express
const express = require('express');
// 解析application/json或者application/x-www-form-urlencoded
var bodyParser = require('body-parser')
// 第二步: 创建web服务器
const app = express();
// parse application/x-www-form-urlencoded
// app.use(bodyParser.urlencoded({ extended: false }))

// 解析application/json
app.use(bodyParser.json())

app.post('/wpfk/getEnterpriseInfo',function(req,res,next){
    console.log(req.body.qymc)
    res.send('Hello world.')
})
// 第三步: 启动服务器
app.listen(3000, ()=>{
 console.log( ' 300服务启动了' )
 })
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/52817074df3a4850b82f8c53e287f8b0~tplv-k3u1fbpfcp-zoom-1.image)

#### `python` `flask`框架接收`POST`参数
```python
from flask import Flask,request
app = Flask(__name__)

@app.route('/wpfk/getEnterpriseInfo',methods=["GET","POST"])
def index():
    # 接收POST请求参数 Content-Type为application/json
    params1 = request.get_json()['qymc']
    # 或者
    params2 = request.json.get('qymc')
    print(params1,params2)
    return '<h1>Hello World</h1>'

if __name__ == '__main__':
    app.run()
```
![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/728fa4ce9af94e0a9e026130a03aad0f~tplv-k3u1fbpfcp-zoom-1.image)

> - 问：为什么不写一个`java`的接收参数😧。<br> 
> - 答：我不会😌!
> - 问：为什么在发起请求的时候 请求类型`multipart/form-data`需要设置请求头而其他情况不需要设置请求头😧？
> - 实际上在其他请求中设置请求头也是不会出错的🥠，但是由于智能的`axios`跟`postman`一样会自动设置不同的请求头，我们就不需要在重新设置啦😙。`axios`在传递`json`序列化参数的时候默认的请求头是`application/json`🥧，所以在请求类型是`multipart/form-data`的时候需要单独指定请求头🍮，否则就会变成`application/json`🍣。

## 总结
以上只是说了比较常用的几种方式，应该可以满足基本的日常工作了🦪，如果你的后端还质疑你的传参就把这篇文章甩过去，愿人间没有`400状态码`存在！🙏
![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7d67dac3ad1749318ea3c684f79868c7~tplv-k3u1fbpfcp-zoom-1.image)

## 参考链接

[常见的Content-Type类型](https://wenku.baidu.com/view/0f6a4e67fd4733687e21af45b307e87101f6f8cf.html)
